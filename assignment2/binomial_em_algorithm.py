# -*- coding: utf-8 -*-
"""binomial_EM_Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10RRoARamjuQd7otIM38QcaY6XTzKsuhX
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import pprint
import matplotlib.pyplot as plt

# %matplotlib inline
#%precision 4
#np.set_printoptions(precision=4)
import pylab as pl

from google.colab import drive
drive.mount("/content/gdrive")
#on running this it will ask permission to mount with google drive. please click ok and allow. this program does not access any of the
# google drive documents except dataset which is uploaded.

#from google.colab import files
#uploaded = files.upload()
#for func in uploaded.keys():
#       print('User uploaded file "{name}"'.format(name=func))

from numpy import genfromtxt
mylist=genfromtxt("/content/gdrive/My Drive/Colab Notebooks/A2Q1.csv", delimiter=',')
print(mylist)

import random
sum_pi=np.zeros(4)
sum_p=np.zeros(4)
for i in range(100):
  initialpartition = []
  for j in range(mylist.shape[0]):
    n = random.randint(1,4)
    initialpartition.append(n)
  
  p=np.random.rand(4)
  #print(p)
  sum_p+=p
  #print(sum_p)
  pi=np.zeros(4)
  for k in range(len(initialpartition)):
    if(initialpartition[k]==1):
      pi[0]+=1
    elif (initialpartition[k]==2):
      pi[1]+=1
    elif (initialpartition[k]==3):
      pi[2]+=1
    elif(initialpartition[k]==4):
      pi[3]+=1

    pi=pi/mylist.shape[0]
    sum_pi+=pi

pi=sum_pi/100
p=sum_p/100
pi=pi/pi.sum(axis=0,keepdims=1)

def Estep(p,pi):
  lambda_t=np.zeros((400,4))
  for i in range(mylist.shape[0]):
    denom=0
    for k in range(0,4):
      sum=1
      for j in range(mylist.shape[1]):
        if(mylist[i][j]==0):
          sum*=(1-p[k])
        else:
          sum*=p[k]
      denom+=(sum*pi[k])
    
    for k in range(0,4):
      sum=1
      for j in range(mylist.shape[1]):
        if(mylist[i][j]==0):
          sum*=(1-p[k])
        else:
          sum*=p[k]
      #sum*=pi[k]
      #print(sum,denom)
        #print(denom)
        
      if(denom!=0): 
        lambda_t[i][k]=((sum*pi[k])/denom)

  
  return lambda_t

def Mstep(lambda_t):
  p=np.zeros(4)
  pi=np.zeros(4)
  for k in range(4):
    denom=0
    for i in range(mylist.shape[0]):
      denom+=lambda_t[i][k]

    sum2=0
    for i in range(mylist.shape[0]):
      sum=0
      
      for j in range(mylist.shape[1]):
        sum+=mylist[i][j] #has the number of zeros in that data point

      sum2+=lambda_t[i][k]*(sum/mylist.shape[1])
    if(denom!=0):
      p[k]=sum2/denom
    #p[k]=p[k]/mylist.shape[1]

    pi[k]=denom/mylist.shape[0]

  return (p,pi)

import math
def calculate_log(p,pi):
  total_sum=0
  for i in range(mylist.shape[0]):
    sum=0
    for k in range(4):
      product_terms=1
      for j in range(mylist.shape[1]):
        if(mylist[i][j]==0):
          product_terms*=(1-p[k])
        else:
          product_terms*=p[k]
      sum+=product_terms*pi[k]
    total_sum+=math.log(sum)
  return total_sum

pprev=np.zeros(4)
piprev=np.zeros(4)
lambda_t=np.zeros((400,4))
i=0
max_log_likelihood=[]
iterations=[]
while(np.linalg.norm(p-pprev)>0.0000001 and np.linalg.norm(pi-piprev)>0.0000001):

  lambda_t=Estep(p,pi)
  #print(lambda_t)
  pprev=p
  piprev=pi
  (p,pi)=Mstep(lambda_t)
  iterations.append(i)
  #print(i)
  i+=1
  log_likelihood=calculate_log(p,pi)
  max_log_likelihood.append(log_likelihood)

plt.plot(iterations,max_log_likelihood)
plt.xlabel("iterations")
plt.ylabel("Log Likelihood")
plt.show()